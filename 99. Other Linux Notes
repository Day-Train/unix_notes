Linux Bootup
	1. When the machine is powered on hardware executes boot code stored in motherboard ROM. This is vendor-specific but generally speaking it determines how to load and initialize the kernel. In many systems this is a two stage process - first hardware loads a small program into memory which secondly arranges for the operating system's kernel to be loaded and initialized via a boot loader. This process occurs outside of Linux, but to describe the boot process it's important to have an OS-agnostic understanding. To that end, this code is typically firmware that can understand disk filesystems, interact on a network and utilize connected devices. On PC-compatible computers this code is the BIOS (Basic Input/Output System) which is stored on the motherboard and set by the motherboard manufacturer. The built-in BIOS, having a basic awareness of connected devices, has configurability to allow which devices the machine should boot from, can determine where the boot loader is stored and how to execute it. It knows this due to the Master Boot Record (MBR) a standards-defined disk block, commonly the first disk block, which captures information about which partition to boot from and the corresponding boot loader for that partition.

	2. Linux uses a boot loader called GRUB which selects and loads the Linux kernel. Before this can happen BIOS loads the GRUB core image into memory, transfers control and executes GRUB's grub_main routine. Among other things, this routine initializes the console, retrieves base addresses, and parses boot configuration information from the filesystem. Boot configuration filenaming varies by Linux distribution but by convention it's always a file in the /boot/grub/ directory. For Debian-based Linux and Solaris it's /boot/grub/menu.lst, for RHEL it's boot/grub/grub.conf. The configuration file includes information for the Linux distribution & version, the root filesystem, and the location of the kernel image. It may also contain multiple entries as GRUB supports multi-booting and non-*nix Operating Systems but that is beyond the scope of this prompt. Once the user, or GRUB if configured to do so by default, selects Linux GRUB executes the kernel boot protocol as defined by a kernel setup header file. GRUB then loads the kernel from /vmlinuz into memory in an address space determined by header file instructions and calculated hardware values (the actual linux filename may be appended to include kernel version and may be a link instead of regular file, check with the vendor documentation for your distribution).

	3. Once the kernel is loaded into memory the boot loader transfers control to the kernel and an architecture-defined assembly routine (typically _start) stored in the header file is executed which initializes the kernel, sets up its stack and ultimately calls its main() routine. The kernel now needs to get a better idea of its environment so it calls a memory detection routine to determine available RAM. The kernel then allocates heap memory and initializes other operating system data structures. Separately from other devices the kernel performs console and keyboard initialization at this time. Additionally, during this stage the Linux trap table is set up. This will allow the operating system to handle hardware interrupts and later on, when no longer in kernel mode, perform limited direct execution during user mode. Next the kernel must identify hardware; Linux polls system buses and inventories hardware devices. As hardware is identified the kernel loads the corresponding drivers. Most implementations of *nix-like operating systems, including Linux, ship with modularized device drivers which can be loaded as hardware is detected. As an aside, while device drivers enable the operating system to abstract away device-specific details this has led to substantial growth in the size of OS code and by extension the number of bugs - approximately 70% of modern Linux OS code is device drivers.

	4. Now that the kernel has a better awareness of its environment it has to create initial processes. These are created by politely asking the kernel thread to spawn a process, or more technically by calling the start_kernel function of main.c. Depending on the distribution of Linux the number and function of these spontaneous processes will vary but there will always be a an init process with PID 1. Note that these initial processes are created differently from all other processes which use the UNIX process API and in particular the fork() and exec() system calls.

	5. Finally, basic system services must be started before to complete the boot process. These include running daemons, mountaing filesystems, establishing services (Networking, SSHD, SMTP, DNS, etc...), and handling logins. These are accomplished via start up scripts which are shell scripts executed by the init process. I'll note that *nix operating systems have a concept of run level which can be thought of as the level of readiness of the system. For most distributions of Linux this increments from 0-6 where 0 is powered off, 1-4 are intermediate or protected stages during startup, 5 is fully booted and 6 is a special run-level that passes a command to reboot. You might imagine that a Linux system begins at run level 0, is then powered on and begins moving up in run level as system services are started and the system reaches a state of complete readiness. Startup scripts are located in the /etc/init.d directory but are symbolically-linked in separate directories by their corresponding run level so the init process can execute services that have process dependencies in the correct order. init receives guidance on what to do at each run level and adjustment to and from run-level from a configuration file called inittab which, as is standard practice for Linux is stored in the /etc directory. Because startup scripts are no different than typical bash scripts you or I might write init is able to manage services by passing it command line arguments (start or stop, along with appropriate flags or other configuration information). Once run level 5 is reached the Linux login process script runs you can login.